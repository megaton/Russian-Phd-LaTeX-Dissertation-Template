\chapter{Обзор публикаций и программного обеспечения по теме исследования} \label{chapt1}

\todo{section Классификация геометрических представлений?}

\section{Представления твердотельной геометрии} \label{sect1_1}

Твёрдое тело – область трёхмерного пространства, состоящая из однородного материала и ограниченная замкнутой поверхностью.
Грань – гладкая (не обязательно плоская) часть поверхности детали, ограниченная замкнутым контуром из рёбер. Частный случай – шарообразные твёрдые тела и тела вращения с гладким профилем, состоящие из единой грани, которая, соответственно, не имеет рёбер.

Ребро – пространственная кривая произвольной конфигурации, полученная на пересечении двух граней.

Вершина – точка в трёхмерном пространстве. Для твёрдого тела это может быть одна из точек на конце ребра.

\section{Твердотельное моделирование} \label{solid_modeling}

Трёхмерная твердотельная геометрия играет важную роль во многих научных и инженерных областях. Также она совершенно необходима для областей связанных с производством.

Для геометрического моделирования предметов, занимающих конечный объем, в математике используются объекты, называемые твердыми телами (rigid body). При моделировании тел строятся поверхности, отделяющие занимаемую ими часть пространства от остальной части пространства. На практике используется несколько представлений геометрии "--- подходов к описанию твердых тел.

Понятие твердотельного моделирования опирается на потребность в информационной полноте в системах механического геометрического моделирования в том смысле, что любая компьютерная модель должна отвечать на все геометрические вопросы, которые могут быть заданы по отношению к соответствующему физическому объекту. Это требование не противоречит возможности существования нескольких компьютерных представлений одного и того же физического объекта, если такие представления согласованы. Невозможно вычислительно проверить информационную полноту представления, если понятие физического объекта не определено в терминах вычислимых математических свойств и не зависит от какого-либо конкретного представления. Такие рассуждения привели к разработке парадигмы моделирования, которая сформировала область твердотельного моделирования, как мы ее знаем сегодня.

Все изготовляемые компоненты имеют конечный размер и имеют чётко определённые границы, поэтому изначально основное внимание уделялось математическому моделированию твердых тел из однородного изотропного материала, к которым можно было бы добавлять или удалять материал (симулируя производственные процессы). Эти свойства можно перевести в свойства подмножеств трехмерного евклидова пространства. Два общих подхода к определению твердотельности основаны на топологии множеств точек и алгебраической топологии соответственно. Обе модели указывают, как твердые тела могут быть построены из простых частей или ячеек.

Согласно модели твердотельности основанной на множествах точек, все точки любого $X \in \mathbf{R}^3$ можно классифицировать по их окрестностям относительно $X$ как внутреннюю, внешнюю или граничную точку. Окрестность точки $p \in X$ принимает вид открытого шара. Для того чтобы множество $X$ считалось сплошным (твердотельным), каждая окрестность любой $p \in X$ должна быть трехмерной. Точки с окрестностями более низких размерностей указывают на отсутствие твердотельности.

\todo{...}

Таким образом, любая схема представления геометрия является методом хранения информации о классе \todo{полу-аналитических} подмножеств евклидова пространства. Это означает, что все представления представляют собой разные способы организации одних и тех же геометрических и топологических данных в форме структур данных. Однако, моделируемое пространство каждого отдельно взятого представления геометрии ограничено, и ни одна схема представления геометрии не может представить все возможные твердые тела. Например, тела представленные граничным представлением (Boundary representation) не всегда могут быть представлены телом движения (sweep solid), кроме простейших случаев. Это заставляет современные системы геометрического моделирования поддерживать несколько схем представления твердых тел, а также способствовать эффективному преобразованию схем представления.

Обзор основных представлений твердотельной геометрии дан \cite{Requicha80} ещё в 1980 году. Там же приведён перечень формальных свойств (таких как уникальность, однозначность и т.п.) систем представления твердых тел Однако поиск оптимальных представлений для конкретных задач и исследование гибридных схем продолжаются и по сей день.

Ниже приведён обзор основных подходов к представлению твердых тел.

\section{\todo{Инстанцирование} параметризованных примитивов} \label{sect_primitive_instatiation}

Один из первых подходов к представлению твердых тел возник в области производства, главным образом в контексте так называемой Group Technology \cite{Gall73}. Он основан на понятии семейств объектов, при этом каждый член семейства отличается от других уникальным набором параметров. Каждое семейство иначе может быть названо \textit{обобщенным примитивом}, отдельные объекты в семействе называются \textit{экземплярами примитива}. Экземпляры примитивов задаются конечным набором параметров.

Отличительной характеристикой чистого подхода инстанцирования примитивов, является отсутствие средств комбинирования примитивов для создания новых, более сложных объектов.

Такая схема представления твердотельной геометрии удобна и проста в использовании, но только до тех пор пока набор обобщённых примитивов и их параметров достаточно мал. Другим недостатком представления является сложность построения алгоритмов для вычисления свойств представляемых тел. Каждое семейство примитивов приходится обрабатывать как специальный случай, что не позволяет единообразно обрабатывать геометрию.

\section{\todo{Перечисление заполнения пространства}} \label{sect_spatial_occupancy_enum}

Представление тела в виде \textit{перечисления заполнения пространства} (Spatial Occupancy Enumeration), более известное, в настоящее время \todo{citation needed}, как \textit{воксельное} представление, представляет из себя список пространственных ячеек, занимаемых телом. Эти ячейки, также называемые вокселями, являются параллелепипедами фиксированного размера и лежат в фиксированной пространственной сетке. В такой системе, каждая ячейка может быть представлена координатами единственной точки, например центроидом ячейки. Обычно подразумевается также определённый порядок обхода сетки. Соответствующие упорядоченные наборы ячеек называют \textit{пространственными массивами} (\textit{spatial arrays}).

Пространственные массивы, как правило, слишком подробны (избыточны) в качестве основного представления для моделирования однородных твердых тел, при достижении требуемой точности аппроксимации. Однако алгоритмы и структуры данных могут быть существенно проще.

Подробность воксельного представления может быть скомпенсирована правильно выбранной иерархической структурой данных (за счет пропуска пустого и/или однородного пространства) ценой усложнения алгоритмов обработки данных. Уже в работе \cite{REDD78} предлагалось строить дерево адаптивных разбиений пространства для уменьшения объема хранимых данных.

\todo{SVO}
\todo{volume compression, wavelets? kaufman1996}

\section{\todo{Декомпозиция на ячейки}} \label{sect_cell_decompositions}

Твердое тело может быть представлено разложением на набор ячеек. Схемы воксельного представления являются частными случаями разложения на ячейки, где все ячейки представленны параллелограммами и лежат в регулярной сетке. Более подробное определение в \cite{Requicha80}.

Наиболее распространенным частным случаем декомпозиции на ячейки является триангуляция. Сплошная триангуляция плоскогранного тела представляет из себя разложение тела на составляющие тетраэдры, которые должны быть непересекающимися, либо иметь ровно одну общую грань, либо ребро, либо вершину. Тело с криволинейной поверхностью, в принципе, таким же образом может быть триангулированно с разложением на криволинейные тетраэдры (\todo{цитата?}), однако такой вариант в настоящее время практически не используется из-за повышенной сложности создания и обработки геометрии.

Представление тела в виде сплошной триангуляции используется, в основном, для расчетов методом конечных элементов, для численного решения уравнений в частных производных.

В работе \cite{A combined octree/Delaunay method for fully automatic 3-d mesh generation} 1990 был предложен полностью автоматический метод построения сплошной триангуляции для твердого тела с использованием окто-дерева и Делоне триангуляции.

В работе \cite{Modeling with Simplicial Complexes} 1996 топологическая концепция симплициального комплекса ставится в соответствие триангуляции для твердотельного моделирования. 

\todo{TetWild}

\todo{тела заметания! но поверхность движения?}

\section{Заметание} \label{sect_sweeping}

Множество точек движущееся через пространство заметает определённый объем (тело), который может быть однозначно задан движущимся множеством точек и траекторией. Такое представление важно, например, для определения части материала, удаляемого фрезой при производстве, по мере её перемещения по заданной траектории. Большинство коммерческих САПР-систем предоставляют ограниченные функциональные возможности для создания тел заметания. Как правило, используется формирование тела заметания трансляцией или вращением замкнутой плоской фигуры. В первом случае процесс формирования называется заметанием при трансляции (translational sweeping), во втором случае "--- построением фигуры вращения (swinging, rotational sweeping).

\section{Граничные представления} \label{sect_boundary_rep}

В этой схеме твердое тело представлено с помощью задания его границы из элементов различных поверхностей. Так как граница твердого тела должна быть замкнута, каждая точка в пространстве однозначно может быть классифицирована как находящаяся внутри или снаружи тела. Используя технику бросания луча, можно подсчитать количество пересечений  луча с границей твердого тела. Четное число пересечений соответствует внешним точкам, а нечетное "--- внутренним. Корректное (\todo{манифолдное}) граничное представление твердого тела должно удовлетворять следующим условиям: все пары вершин не совпадают, пары ребер либо не пересекаются, либо пересекаются в одной вершине, а пары граней не пересекаются или пересекаются на общем ребре либо в общей вершине. Для хранения граничных представлений твердых тел были разработаны несколько структур данных, представляющих собой \todo{комбинаторные карты}. В дополнение к плоскостным граням современные системы, использующие граничное представление, обеспечивают поддержку поверхностей второго порядка и NURBS поверхностей. Граничные представления стали доминирующей схемой представления твердых тел в большинстве коммерческих систем из-за их гибкости и универсальности.

\todo{публикации, много}

\section{Конструктивная блочная геометрия} \label{sect_csg}

Конструктивная блочная геометрия (Constructive Solid Geometry или CSG) представляет собой семейство схем для представления твердых тел в виде булевых комбинаций примитивов с помощью регуляризованных операций булевой логики на множествах. CSG представления имеют форму упорядоченных двоичных деревьев, где нетерминальные (внутренние) узлы представляют собой либо твердотельные преобразования (перенос и поворот), либо регуляризованные операции на множествах. Терминальные (листовые) узлы являются примитивами, представляющими замкнутые регулярные множества. Таким образом каждое поддерево представляет собой множество, полученный в результате применения указанных операций на множестве, представленном листовыми примитивами поддерева. Привлекательные свойства CSG включают в себя компактность, гарантированную корректность твердых тел (при использовании корректных твердых тел в качестве примитивов), и естественный контроль формы твердого тела в терминах параметров высокого уровня, определяющих примитивы твердого тела, их положения и ориентации. Относительно простая структура данных и изящные рекурсивные алгоритмы еще больше способствовали популярности CSG на заре развития САПР систем и геометрического моделирования. Позже, проблемы CSG подхода как основного представления твердых тел всё же перевесили его преимущества, среди них: сложность прямой визуализации CSG объектов (без перехода к граничному представлению), сложность перехода к граничному представлению, сложность задания незамкнутых объектов (это возможно если использовать незамкнутые примитивы, но тогда необходимо отказаться от одного из главных преимуществ — гарантированной корректности) и т. д. Сейчас CSG представление используется в основном, как вспомогательное или промежуточное представление, для выполнения булевых операций над телами.

В работе \cite{Requicha 77} года были заложены четкие теоретические основы подхода. Потом в статье 80 года понятие твердотельного моделирования связано с булевой логикой на р-сетах. Дальнейшее развитие в статье 85 года. Язык падл-1 и падл-2, в каких системах использовали CSG?

ох я не знаю что это
\cite{Computable Operators on Regular Sets}

\section{Неявные представления} \label{sect_implicit}

р-функции рвачева, дистанс фиелды?

Очень общий метод определения множества точек X - это указать предикат, который можно оценить в любой точке пространства. Другими словами, X определяется неявно, чтобы состоять из всех точек, которые удовлетворяют условию, заданному предикатом. Простейшей формой предиката является условие знака вещественной функции, приводящее к знакомому представлению множеств по равенствам и неравенствам. Например, если f = ax + by + cz + d {\ displaystyle f = ax + by + cz + d} f = ax + by + cz + d условия f (p) = 0 {\ displaystyle f (p) = 0} f (p) = 0, f (p)> 0 {\ displaystyle f (p)> 0} f (p)> 0 и f (p) <0 {\ displaystyle f (p) <0} f (p) <0 представляют соответственно плоскость и два открытых линейных полупространства. Более сложные функциональные примитивы могут быть определены с помощью булевых комбинаций более простых предикатов. Кроме того, теория R-функций допускает преобразование таких представлений в одно функциональное неравенство для любого замкнутого полуаналитического множества. Такое представление может быть преобразовано в граничное представление с использованием алгоритмов полигонизации, например, алгоритма марширующих кубов.

\section{Подходы к визуализации геометрии} \label{sect_geom_vis}

\todo{TODO}

растеризация линий
wireframe

визуализация b-rep

растеризация треугольников

определение видимости

художник

z-buffer

bsp-дерево

рейтрейсинг

прямой рейтрейсинг nurbs и квадрик?

volume rendering?

\section{Подходы к визуализации CSG} \label{sect_csg_vis}

\todo{Булевы операции vs алгебраические операции над множествами}

\todo{хронологически}

Самым ранним способом визуализации CSG моделей была отрисовка линиями (wireframe). Для этого необходимо построить линии пересечения всех поверхностей в модели и спроектировать их на экранную плоскость. Позже, этот метод начали дополнять удалением невидимых линий. [e.g. Appel67], [An algorithm for eliminating the hidden lines in computer-drawn polyhedra 68]

Идея применения трассировки лучей (ray casting) для визуализации CSG моделей, по видимому, принадлежала [Goldstein and Nagel]. В этой работе трассировка лучей применяется для получения \todo{shaded} изображений твердотельных моделей. Чтобы получить такое изображение Goldstein and Nagel моделировали процесс, обратный фотографии. Для каждого пикселя изображения, они строят лучи и определяют его пересечение с виртуальной сценой. Ближайшее к наблюдателю пересечение луча с поверхностью, определяет видимую поверхность. Вычислив нормаль к поверхности в точке пересечения и зная положение источника света, можно рассчитать яркость каждого пикселя. Кратко формулируется идея алгоритма пересечения луча и CSG модели. Каждая точка пересечения луча и геометрии (в порядке от ближних к дальним) анализируется на принадлежность логическому выражению, соответствующему части модели -- региону. На основе этого метода была разработана коммерческая CAD/CAM система SynthaVision, которая позволяла получать \todo{wireframe} и \todo{shaded} изображения твердотельных моделей.

Многие эксперты в CAD/CAM области того времени считали трассировку лучей непрактичным методом "грубой силы" [Roth]. [Roth] в своей работе приводит практическое описание алгоритма трассировки лучей для задачи визуализации CSG моделей, а также приводит оптимизации алгоритма. [Roth] использует ограничивающие объемы (enclosures, camera space AABB?) для ускоренного отбрасывания CSG поддеревьев гарантированно непересекающихся с лучом. [Roth] делает вывод о важности пространственной когерентности примитивов в дереве и предполагает, что CSG дерево может быть автоматически пере-упорядочено, для улучшения пространственной когерентности. Дальнейшие оптимизации были предложены в работе [Bronsvoort84].

Алгоритмы бросания лучей [Roth, Goldstein and Malin] применяют один и тот же алгоритм 
Алгоритмы бросания (ray-firing) лучей [Roth, Goldstein and Malin] применяют один и тот же алгоритм для каждой точки на экране для определения видимости поверхностей. Задача поиска поверхности соответствующей CSG выражению {сводится к одномерной задаче на луче. Формализованная классификация одномерных \todo{алгоритмов} решения Булевых выражений дана в работе \todo{[Tilove(atheron-15)]}. Главным преимуществом подходов основанных на бросании лучей является отсутствие необходимости вычислять полную граничную поверхность соответствующую CSG модели. Для определения видимой точки на луче пересекающем CSG модель можно использовать следующий алгоритм:

\includegraphics[]{1.png}}

\todo{Рисунок 3} показывает простоту вычисления Булевых операций в одномерном пространстве для двух примитивов. В дополнение к простоте, метод имеет дополнительное преимущество для визуализации "--- после того как ближайшая точка определена, дальнейшие вычисления можно отбросить. Однако, перед тем как применить эти простые правила, необходимо пересечь луч с CSG примитивами и отсортировать точки пересечения. К тому же, все эти шаги должны быть выполнены для каждого пикселя изображения. [Roth] описывает процедуру отсечения для уменьшения числа поверхностей, с которыми нужно пересечь луч для каждого пикселя. Однако, хотя такая оптимизация и дает эффект, тем не менее вычислительная сложность алгоритма не меняется. [Roth] также приводит метод для определения и визуализации только силуэта и линий пересечения поверхностей, но этот метод не совместим с \todo{shaded} визуализацией.

\includegraphics[]{2.png}}

Широко используемый в то время (1980е) для задачи определения видимости полигонов, \todo{построчный подход} к визуализации (scanline rendering), также был адаптирован для визуализации CSG моделей [atherton1983]. Типичный scanline алгоритм использующий Y-X-Z сортировку полигонов представлен ниже:

\includegraphics[]{scanline.png}}

Сегментом в scanline алгоритмах называется часть полигона образованная пересечением scanline плоскости и полигона.
Интервалом называется непрерывная часть scanline, для которой возможно определить видимый сегмент. 

Алгоритм предложенный [atherton1983] использует те же 4 шага что и обычный алгоритм scanline, однако вместо определения видимости сегмента в интервале по его близости к виртуальной камере (наблюдателю), используется более сложная процедура, аналогичная процедуре поиска видимой поверхности с помощью трассировки луча, примененной к концам интервала. В случае если для концов интервала видимыми становятся разные поверхности, интервал рекурсивно разбивается.

Как и все scanline алгоритмы [atherton1983] пытается использовать \todo{свойства когерентности} геометрии для оптимизации вычислений. Когерентность интервалов можно считать первым улучшением по сравнению с трассировкой лучей. Если на границах интервала видима одна и та же поверхность, то и результаты расчета освещения (shading) можно интерполировать между концами интервала.

\todo{Визуализация CSG на ЦПУ? ранние подходы}

Все разнообразие алгоритмов визуализации CSG моделей можно разделить на три базовых подхода. Первый подход основан на предварительном расчете полной границы CSG объекта (переход к граничному представлению), которая затем тесселируется и визуализируется с использованием традиционных инструментов 3D графики (Direct3D, OpenGL). Поскольку расчет границы является  вычислительно трудоемкой операцией, алгоритмы данной группы зачастую применимы только для статических сцен и не позволяют выполнять интерактивное редактирование конструктивных моделей.

Второй подход основан на переходе к воксельному представлению (spatial enumeration), для этого достаточно иметь возможность классифицировать точку относительно CSG дерева. После этого геометрию можно визуализировать как 3Д текстуру, средствами volume rendering. К недостатком такого подхода можно отнести большой объем занимаемого пространства и ограниченную точность представления (шагом воксельной сетки). Однако такой подход достаточно прост и производительность визуализации не зависит от сложности CSG дерева. Hardware-based slicing algorithm for CSG [58, 44].

Третий подход построен на базе техник анализа изображения (англ. image-based), которые генерируют только изображение CSG модели с заданного ракурса, избегая трудоемких вычислений полной границы. Большинство таких методов разработано для графической аппаратуры и реализуется с помощью многопроходных и зависящих от ракурса техник, интенсивно использующих буферы глубины и трафарета. В рамках данного подхода широкое распространение получили алгоритм Goldfeather [1, 2] и алгоритм последовательного вычитания выпуклых оболочек (англ. Sequenced Convex Subtraction, SCS) [3]. Первый из них поддерживает любые CSG примитивы, в то время как второй применим только к сценам, состоящим из выпуклых примитивов. При этом ни один из указанных  алгоритмов не позволяет визуализировать конструктивные модели напрямую. Вместо этого, CSG выражение должно быть преобразовано в дизъюнктивную нормальную форму (дизъюнкция с минимальным числом элементарных конъюнкций), что может приводить к экспоненциальному росту размера булевой формулы, значительно ограничивая  масштабируемость и производительность алгоритмов. \todo{Позже} был предложен алгоритм Improved Layered Goldfeather Algorithm (General purpose Z-buffer CSG rendering with consumer level hardware). Обзор техник использующих буфер глубины представлен в работе [93]. Визуализация CSG моделей с использованием двустороннего теста глубины описанная в [42] позволила улучшить разложение сцены по слоям, используя аппаратный тест глубины для расчета теней. В работе [52] были предложены улучшения SCS алгоритма, закадровый (англ. off-screen) рендеринг, поддерживаемый теперь аппаратно, наряду с запросом видимости OpenGL (для вычисления количества слоев) позволили увеличить производительность метода. 3D-графическая библиотека OpenCSG [53] реализует интерактивный рендеринг CSG с использованием алгоритмов: Goldfeather, SCS, \todo{...}. 

Альтернативный подход был предложен в более поздней работе [4] и получил название Blister. Вместо нормальной формы, данный метод преобразует CSG формулу к списку Blist [5], содержащему каждый примитив ровно один раз. Для визуализации заданной конструктивной модели Blister задействует многопроходную технику разложения сцены по слоям (англ. depth peeling), с помощью которой входная сцена разбивается на слои, все фрагменты которых имеют одинаковый индекс близости (занимают равные позиции в списке фрагментов, отсортированных по мере удаления от камеры). Точки каждого слоя классифицируются согласно заданному CSG выражению и комбинируются для синтеза окончательного изображения. Показано, что для модели с k слоями глубины и n примитивами алгоритм вычисляет изображение за время O(kn). В худшем случае k линейно зависит от n, поэтому трудоемкость следует оценить как O(n2).

Subsequent to the Blister approach, the Constructive Solid Trimming (CST) algorithm [46] and Optimised Blist Form [76].

Transparent and edge-enhanced interactive CSG rendering [67].

A surfel approach to CSG rendering [13].

Hardware-based slicing algorithm for CSG [58, 44].

Указанные выше алгоритмы обеспечивают интерактивное отображение конструктивных моделей малой или средней  сложности (от нескольких сотен до нескольких десятков тысяч примитивов). При этом их общей чертой является активное использование многопроходных схем, которые ставят скорость рендеринга в зависимость от пропускной способности памяти. На протяжении последних десяти лет пропускная способность памяти GPU растет значительно медленнее производительности вычислительных модулей,  что делает передачу данных узким местом во многих GPU алгоритмах.

Альтернативный подход к визуализации конструктивных сцен был предложен в работе [6], где была предпринята попытка распределения вычислений между центральным и графическим процессором. Для этого входное CSG дерево декомпозируется на простые составляющие (содержащие малое число примитивов), которые затем визуализируются на GPU методом трассировки лучей. Входной CSG объект разбивается до тех пор, пока отдельные его части не будут соответствовать одиночным CSG примитивам или булевой  комбинации двух примитивов. Очевидно, что некоторые фрагменты модели не могут быть разбиты согласно двум указанным случаям (области, содержащие вершины 3-ого и более высоких порядков). Такие фрагменты алгоритмом отбрасываются, что выражается в визуальных артефактах при попытке увеличить изображение на экране монитора. Хотя данный подход оказался эффективным для простых сцен (сотни примитивов), более сложные модели требуют разбиения на большое число простых частей, что ведет к значительному росту числа вызовов отрисовки (англ. draw call) и снижению производительности.

Трассировка лучей для поиска пересечения с целым CSG деревом также возможна и применяется довольно широко. Однако большинство подходов к визуализации CSG сцен требует расчета всех пересечений луча с составляющими объект примитивами. При этом луч разбивается на набор интервалов, соответствующих пересекаемым примитивам. Затем к ним применяются правила булевой алгебры для вычисления ближайшей точки, расположенной на границе конструктивного объекта. Поскольку луч следует пересечь со всеми примитивами сцены, данный алгоритм является крайне вычислительно затратным. Кроме того, он плохо приспособлен для графических процессоров, которые не имеют ресурсов для хранения такого числа интервалов для десятков тысяч лучей. Тем не менее, для относительно простых сцен “интервальная” трассировка лучей на GPU вполне возможна, что наглядно показано в работе [7]. В любом случае, данный алгоритм плохо масштабируется с ростом сложности сцены и числа слоев (влияет на число интервалов).

Совершенно другой подход к визуализации CSG моделей  на базе трассировки лучей был представлен в работе [8] и основан на поиске ближайших точек соударения лучей с  примитивами 3D сцены. Алгоритм использует концепцию конечного автомата для вычисления точки пересечения с границей CSG модели. При этом требуется, чтобы базовые примитивы были замкнутыми (допустимо обобщение для полупространств, заданных ориентированными поверхностями), имели согласованное поле нормалей и не содержали самопересечений. Элегантность решения и приемлемые ограничения позволяют довольно просто реализовать поддержку конструктивных моделей в любой программной системе, основанной на трассировке лучей. Хотя указанная работа не содержит упоминаний о практических испытаниях алгоритма, он представляется наилучшей основой для разработки специализированной версии для GPU.

\section{Ускоряющие структуры} \label{sect_acceleration_structures}

Для эффективной визуализации многие алгоритмы используют различные структуры данных, которые в контексте визуализации принято называть ускоряющими структурами (англ. acceleration structure). Ускоряющие структуры могут использоваться для пропуска пустого пространства в случае визуализации воксельных представлений. В подходах использующих растеризацию, ускоряющие структуры помогают отсекать невидимую геометрию. Особенно критичны ускоряющие структуры для трассировки лучей. Наиболее трудоемкой операцией в большинстве алгоритмов на базе трассировки лучей является поиск ближайшей точки пересечения луча с объектами сцены. Перед тестированием луча на пересечение с геометрией сцены определяется его пересечение с ускоряющей структурой (данная операция обычно называется «обходом»). В качестве результата ускоряющая структура возвращает ближайшую область пространства с подмножеством примитивов сцены. Процедура трассировки тестирует луч на пересечение с примитивами данного подмножества. Если точка соударения не обнаружена, то ускоряющая структура запрашивается повторно для получения нового подмножества примитивов. Этот процесс продолжается до тех пор, пока для луча не будет найдено соударение или не будет установлено, что данный луч не пересекает сцену.

Расчет точки пересечения луча с объектами сцены относится к задачам поиска, поэтому все ускоряющие структуры реализуют некоторый механизм пространственной сортировки объектов. С точки зрения базового подхода к сортировке все ускоряющие структуры можно разделить на два типа: разбиения пространства (англ. spatial subdivision) и иерархии объектов (англ. object hierarchy). Данные типы являются двойственными по своей природе. Разбиения пространства позволяют уникально представить каждую точку пространства, однако каждый примитив сцены может перекрываться любым числом ячеек. Иерархии объектов позволяют уникально представить каждый примитив, однако каждая точка сцены может перекрываться любым числом ячеек. Примерами разбиений пространства являются такие структуры, как регулярные [11] или иерархические [12] сетки, октодеревья [13] и k-d деревья [14], которые отличаются степенью регулярности [15]. Напротив, иерархии ограничивающих объемов [16] и их варианты (такие как иерархии ограничивающих интервалов [17; 18]) служат примерами иерархий объектов. Развитие методов трассировки лучей неразрывно связано с развитием ускоряющих структур, алгоритмов их построения и обхода. Подробному обзору ускоряющих структур и их относительной эффективности посвящена работа [19].
В большинстве случаев ускоряющие структуры строятся на этапе препроцессирования сцены, поэтому трудоемкость их построения не учитывается на этапе визуализации. Данный подход допустимо применять только для статических сцен (с неизменной геометрией), во время отображения которых возможны перемещения лишь виртуальной камеры и изменения источников света. Для обработки динамических сцен (с подвижной геометрией) необходимо выполнять повторное построение или частичное обновление ускоряющей структуры каждый раз при модификации объектов.

\section{Интерактивное глобальное освещение} \label{sect_GI}

Современный подход к инженерной графике включает в себя расширение визуализации геометрии за счет эффектов глобального освещения. Тем самым повышается наглядность и удобство восприятия, особенно для сложных моделей.

\todo{Картинка}

Существующие подходы как правило ограничиваются частичной поддержкой эффектов глобального освещения для интерактивной визуализации. Используются такие подходы как SSAO и отражения с использованием карт окружения \todo{ссылки}. Однако, для многих задач требуется полноценный расчет глобального освещения.

Корректный расчет глобального освещения характеризуется высокой вычислительной трудоемкостью, поэтому большинство интерактивных систем базируется на упрощенных моделях, которые сочетают приемлемое быстродействие и высокое качество визуализации. Для интерактивного расчета глобального освещения применяются различные подходы [111], такие как метод излучательности (англ. radiosity), стохастическая трассировка путей (англ. stochastic path tracing), метод фотонных карт (англ. photon mapping), метод «мгновенной» излучательности (англ. instant radiosity), «многосветовые» (англ. many-light-based) подходы, точечные подходы (англ. point-based) или «микрорендеринг» (англ. micro-rendering) и метод дискретных координат (англ. discrete ordinate). Кроме того, для повышения быстродействия практически всех перечисленных алгоритмов могут применяться схемы кэширования.

В настоящей работе используется трассировка лучей как основной метод визуализации CSG деревьев. Реализованная операция бросания луча позволяет естественным образом расширить подход для расчета глобального освещения используя (стохастическую) трассировку путей, которая решает уравнение визуализации методом Монте-Карло. Хотя современные графические ускорители обрабатывают свыше 100 миллионов случайных лучей в секунду, некогерентность вторичных отскоков является основной проблемой эффективных реализаций [112]. Быстрое разветвление путей ведет к плохой утилизации вычислительных ресурсов и снижает эффективность доступа к памяти.

\todo{ещё про трассировку путей?}

\todo{полноценный обзор методов?}

\todo{обзор сапр и их возможностей по визуализации?}

%==============================================================================
\todo{END OF TEXT}
%==============================================================================

% дальше идут LATEX примеры

Мы можем сделать \textbf{жирный текст} и \textit{курсив}.

%\newpage
%============================================================================================================================

\section{Ссылки} \label{sect1_2}
Сошлёмся на библиографию.
Одна ссылка: \cite[с.~54]{Sokolov}\cite[с.~36]{Gaidaenko}.
Две ссылки: \cite{Sokolov,Gaidaenko}.
Много ссылок: %\cite[с.~54]{Lermontov,Management,Borozda} % такой «фокус» вызывает biblatex warning относительно опции sortcites, потому что неясно, к какому источнику относится уточнение о страницах, а bibtex об этой проблеме даже не предупреждает
\cite{Lermontov,Management,Borozda,Marketing,Constitution,FamilyCode,Gost.7.0.53,Razumovski,Lagkueva,Pokrovski,Sirotko,Lukina,Methodology,Encyclopedia,Nasirova,Berestova,Kriger}.
И ещё немного ссылок:
\cite{Article,Book,Booklet,Conference,Inbook,Incollection,Manual,Mastersthesis,Misc,Phdthesis,Proceedings,Techreport,Unpublished}.
\cite{medvedev2006jelektronnye, CEAT:CEAT581, doi:10.1080/01932691.2010.513279,Gosele1999161,Li2007StressAnalysis, Shoji199895,test:eisner-sample,AB_patent_Pomerantz_1968,iofis_patent1960}

%Попытка реализовать несколько ссылок на конкретные страницы для стандартной реализации:[\citenum{Sokolov}, с.~54; \citenum{Gaidaenko}, с.~36].

%Несколько источников мультицитата \cites[vii--x, 5, 7]{Sokolov}[v--x, 25, 526]{Gaidaenko} поехали дальше

Ссылки на собственные работы:~\cite{vakbib1, confbib1}

Сошлёмся на приложения: Приложение \ref{AppendixA}, Приложение \ref{AppendixB2}.

Сошлёмся на формулу: формула \eqref{eq:equation1}.

Сошлёмся на изображение: рисунок \ref{img:knuth}.

%\newpage
%============================================================================================================================

\section{Формулы} \label{sect1_3}

Благодаря пакету \textit{icomma}, \LaTeX~одинаково хорошо воспринимает в качестве десятичного разделителя и запятую ($3,1415$), и точку ($3.1415$).

\subsection{Ненумерованные одиночные формулы} \label{subsect1_3_1}

Вот так может выглядеть формула, которую необходимо вставить в строку по тексту: $x \approx \sin x$ при $x \to 0$.

А вот так выглядит ненумерованая отдельностоящая формула c подстрочными и надстрочными индексами:
\[
(x_1+x_2)^2 = x_1^2 + 2 x_1 x_2 + x_2^2
\]

При использовании дробей формулы могут получаться очень высокие:
\[
  \frac{1}{\sqrt{2}+
  \displaystyle\frac{1}{\sqrt{2}+
  \displaystyle\frac{1}{\sqrt{2}+\cdots}}}
\]

В формулах можно использовать греческие буквы:
\[
\alpha\beta\gamma\delta\epsilon\varepsilon\zeta\eta\theta\vartheta\iota\kappa\lambda\\mu\nu\xi\pi\varpi\rho\varrho\sigma\varsigma\tau\upsilon\phi\varphi\chi\psi\omega\Gamma\Delta\Theta\Lambda\Xi\Pi\Sigma\Upsilon\Phi\Psi\Omega
\]

\def\slantfrac#1#2{ \hspace{3pt}\!^{#1}\!\!\hspace{1pt}/
  \hspace{2pt}\!\!_{#2}\!\hspace{3pt}
} %Макрос для красивых дробей в строчку (например, 1/2)
Для красивых дробей (например, в индексах) можно добавить макрос
\verb+\slantfrac+ и писать $\slantfrac{1}{2}$ вместо $1/2$.
%\newpage
%============================================================================================================================

\subsection{Ненумерованные многострочные формулы} \label{subsect1_3_2}

Вот так можно написать две формулы, не нумеруя их, чтобы знаки равно были строго друг под другом:
\begin{align}
  f_W & =  \min \left( 1, \max \left( 0, \frac{W_{soil} / W_{max}}{W_{crit}} \right)  \right), \nonumber \\
  f_T & =  \min \left( 1, \max \left( 0, \frac{T_s / T_{melt}}{T_{crit}} \right)  \right), \nonumber
\end{align}

Выровнять систему ещё и по переменной $ x $ можно, используя окружение \verb|alignedat| из пакета \verb|amsmath|. Вот так: 
\[
    |x| = \left\{
    \begin{alignedat}{2}
        &&x, \quad &\text{eсли } x\geqslant 0 \\
        &-&x, \quad & \text{eсли } x<0
    \end{alignedat}
    \right.
\]
Здесь первый амперсанд (в исходном \LaTeX\ описании формулы) означает выравнивание по~левому краю, второй "--- по~$ x $, а~третий "--- по~слову <<если>>. Команда \verb|\quad| делает большой горизонтальный пробел.

Ещё вариант:
\[
    |x|=
    \begin{cases}
    \phantom{-}x, \text{если } x \geqslant 0 \\
    -x, \text{если } x<0
    \end{cases}
\]

Кроме того, для  нумерованых формул \verb|alignedat|  делает вертикальное
выравнивание номера формулы по центру формулы. Например,  выравнивание компонент вектора:
\begin{equation}
 \label{eq:2p3}
 \begin{alignedat}{2}
{\mathbf{N}}_{o1n}^{(j)} = \,{\sin} \phi\,n\!\left(n+1\right)
         {\sin}\theta\,
         \pi_n\!\left({\cos} \theta\right)
         \frac{
               z_n^{(j)}\!\left( \rho \right)
              }{\rho}\,
           &{\boldsymbol{\hat{\mathrm e}}}_{r}\,+   \\
+\,
{\sin} \phi\,
         \tau_n\!\left({\cos} \theta\right)
         \frac{
            \left[\rho z_n^{(j)}\!\left( \rho \right)\right]^{\prime}
              }{\rho}\,
            &{\boldsymbol{\hat{\mathrm e}}}_{\theta}\,+   \\
+\,
{\cos} \phi\,
         \pi_n\!\left({\cos} \theta\right)
         \frac{
            \left[\rho z_n^{(j)}\!\left( \rho \right)\right]^{\prime}
              }{\rho}\,
            &{\boldsymbol{\hat{\mathrm e}}}_{\phi}\:.
\end{alignedat}
\end{equation}

Ещё об отступах. Иногда для лучшей <<читаемости>> формул полезно
немного исправить стандартные интервалы \LaTeX\ с учётом логической
структуры самой формулы. Например в формуле~\ref{eq:2p3} добавлен
небольшой отступ \verb+\,+ между основными сомножителями, ниже
результат применения всех вариантов отступа:
\begin{align*}
\backslash! &\quad f(x) = x^2\! +3x\! +2 \\
  \mbox{по-умолчанию} &\quad f(x) = x^2+3x+2 \\
\backslash, &\quad f(x) = x^2\, +3x\, +2 \\
\backslash{:} &\quad f(x) = x^2\: +3x\: +2 \\
\backslash; &\quad f(x) = x^2\; +3x\; +2 \\
\backslash \mbox{space} &\quad f(x) = x^2\ +3x\ +2 \\
\backslash \mbox{quad} &\quad f(x) = x^2\quad +3x\quad +2 \\
\backslash \mbox{qquad} &\quad f(x) = x^2\qquad +3x\qquad +2
\end{align*}


Можно использовать разные математические алфавиты:
\begin{align}
\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ} \nonumber \\
\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ} \nonumber \\
\mathbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ} \nonumber
\end{align}

Посмотрим на систему уравнений на примере аттрактора Лоренца:

\[ 
\left\{
  \begin{array}{rl}
    \dot x = & \sigma (y-x) \\
    \dot y = & x (r - z) - y \\
    \dot z = & xy - bz
  \end{array}
\right.
\]

А для вёрстки матриц удобно использовать многоточия:
\[ 
\left(
  \begin{array}{ccc}
  	a_{11} & \ldots & a_{1n} \\
  	\vdots & \ddots & \vdots \\
  	a_{n1} & \ldots & a_{nn} \\
  \end{array}
\right)
\]


%\newpage
%============================================================================================================================
\subsection{Нумерованные формулы} \label{subsect1_3_3}

А вот так пишется нумерованая формула:
\begin{equation}
  \label{eq:equation1}
  e = \lim_{n \to \infty} \left( 1+\frac{1}{n} \right) ^n
\end{equation}

Нумерованых формул может быть несколько:
\begin{equation}
  \label{eq:equation2}
  \lim_{n \to \infty} \sum_{k=1}^n \frac{1}{k^2} = \frac{\pi^2}{6}
\end{equation}

Впоследствии на формулы (\ref{eq:equation1}) и (\ref{eq:equation2}) можно ссылаться.

Сделать так, чтобы номер формулы стоял напротив средней строки, можно, используя окружение \verb|multlined| (пакет \verb|mathtools|) вместо \verb|multline| внутри окружения \verb|equation|. Вот так:
\begin{equation} % \tag{S} % tag - вписывает свой текст 
  \label{eq:equation3}
    \begin{multlined}
        1+ 2+3+4+5+6+7+\dots + \\ 
        + 50+51+52+53+54+55+56+57 + \dots + \\ 
        + 96+97+98+99+100=5050 
    \end{multlined}
\end{equation}

Используя команду \verb|\labelcref| из пакета \verb|cleveref|, можно
красиво ссылаться сразу на несколько формул
(\labelcref{eq:equation1,eq:equation3,eq:equation2}), даже перепутав
порядок ссылок \verb|(\labelcref{eq:equation1,eq:equation3,eq:equation2})|.

